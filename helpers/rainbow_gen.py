"""Generator for rainbow.*"""

# pylint: disable=duplicate-code,invalid-name

import os

import colour
import numpy as np

def cie_wavelength_to_rgb(wavelength):
    """Use CIE data to convert wavelength to RGB.

    This mirrors the "best compromise" method of Andrew T. Young.
    See https://wejn.org/2026/01/on-the-unreasonable-difficulty-of-plotting-pretty-rainbow-fast/
    """
    cmfs = colour.MSDS_CMFS['CIE 2015 2 Degree Standard Observer']

    if wavelength < 380 or wavelength > 780:
        return (0.0, 0.0, 0.0)

    wl_range = cmfs.wavelengths
    X = np.interp(wavelength, wl_range, cmfs.values[:, 0])
    Y = np.interp(wavelength, wl_range, cmfs.values[:, 1])
    Z = np.interp(wavelength, wl_range, cmfs.values[:, 2])

    XYZ = np.array([X, Y, Z])

    rgb_linear = colour.XYZ_to_sRGB(XYZ, apply_cctf_encoding=False)

    r, g, b = rgb_linear

    if r < 0 or g < 0 or b < 0:
        min_component = min(r, g, b)
        if Y > 0:
            factor = Y / (Y - min_component)
            r = Y + factor * (r - Y)
            g = Y + factor * (g - Y)
            b = Y + factor * (b - Y)

    brightness_boost = 1/1.4
    r *= brightness_boost
    g *= brightness_boost
    b *= brightness_boost

    max_component = max(r, g, b)
    if max_component > 1.0:
        r /= max_component
        g /= max_component
        b /= max_component

    r = max(0.0, min(1.0, r))
    g = max(0.0, min(1.0, g))
    b = max(0.0, min(1.0, b))

    r = colour.models.eotf_inverse_sRGB(r)
    g = colour.models.eotf_inverse_sRGB(g)
    b = colour.models.eotf_inverse_sRGB(b)

    return (r, g, b)

def create_rainbow_strip(start, stop, oversample=5):
    """Create a 1-pixel tall rainbow gradient from violet to red."""
    width = (stop - start) * oversample

    strip = np.zeros((1, width, 3))

    # Map each pixel to a wavelength from 380-780nm
    for i in range(width):
        wavelength = start + (stop - start) * i / (width - 1)
        strip[0, i] = cie_wavelength_to_rgb(wavelength)

    return strip

def main():
    """C-like main."""

    start = 380
    end = 780
    oversample = 5
    rainbow = create_rainbow_strip(start, end, oversample)

    py_output = os.path.abspath(os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        "../tobes_ui/rainbow.py"
    ))

    with open(py_output, "w", encoding="utf-8") as pyfile:
        pyfile.write("#!/usr/bin/env python3\n")
        pyfile.write("\"\"\"Rainbow data, autogenerated by helpers/rainbow_gen.py.\"\"\"\n")
        pyfile.write("\n")
        pyfile.write("# pylint: disable=too-many-lines\n")
        pyfile.write('''
import numpy as np

def get_rainbow_for_range(new_start, new_end):
    """Return rainbow strip (1xX image) with wavelength range (new_start, new_end)."""

    step = 1/OVERSAMPLE
    pad_value = (0.0, 0.0, 0.0)

    n = DATA.shape[1]
    new_coords = np.arange(new_start, new_end + step, step)
    idx = np.round((new_coords - START) / step).astype(int)
    out = np.full((1, len(new_coords), 3), pad_value, dtype=DATA.dtype)
    valid = (idx >= 0) & (idx < n)
    out[0, valid] = DATA[0, idx[valid]]
    return out

''')
        pyfile.write(f"START = {start}\n")
        pyfile.write(f"END = {end}\n")
        pyfile.write(f"OVERSAMPLE = {oversample}\n")
        np.set_printoptions(threshold=np.inf)
        pyfile.write("DATA = np.array(" +
                     np.array2string(rainbow, separator=", ").replace('[[[', '[[\n  [', 1) +
                     ")\n")

    print(f"Wrote: {py_output}")

if __name__ == "__main__":
    main()
